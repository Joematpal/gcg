package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/urfave/cli/v2"
)

func joinFlags(flagSet ...[]cli.Flag) []cli.Flag {
	out := []cli.Flag{}
	for _, flags := range flagSet {

		out = append(out, flags...)
	}
	return out
}

var baseFlags = []cli.Flag{
	&cli.PathFlag{
		Name:    "output",
		Usage:   "the destination where the end file needs to go",
		Aliases: []string{"o"},
	},
	&cli.StringFlag{
		EnvVars: []string{"GOPACKAGE"},
	},
}

var structFlags = []cli.Flag{
	&cli.StringFlag{
		Name:  "fields",
		Usage: "provide the fields with key:value comma seperated; make key snake_case to make it easier to handle capitals for acronyms",
	},
	&cli.BoolFlag{
		Name:    "tags",
		Aliases: []string{"t"},
		Usage:   "this will put the tags in either camel or snake case; default: camel",
	},
	&cli.GenericFlag{
		Name:    "tags-format",
		Aliases: []string{"tf"},
		Value:   NewTagsEnum(),
		Usage:   "this will put the tags in either camel or snake case; default: camel",
	},
	&cli.BoolFlag{
		Name:    "getters",
		Aliases: []string{"g"},
		Usage:   "",
	},
	&cli.BoolFlag{
		Name:    "no-struct",
		Aliases: []string{"ns"},
		Usage:   "allows you to print out the methods with the need for the struct",
	},
	&cli.BoolFlag{
		Name:    "setters",
		Aliases: []string{"s"},
		Usage:   "",
	},
}

type TagsFormat = string

const (
	TagsFormat_camelCase TagsFormat = "camel-case"
	TagsFormat_snakeCase TagsFormat = "snake-case"
)

type TagsEnum struct {
	Enum     []string
	Default  string
	selected string
}

func NewTagsEnum() *TagsEnum {
	return &TagsEnum{
		Enum: []string{
			TagsFormat_camelCase,
			TagsFormat_snakeCase,
		},
		Default: TagsFormat_camelCase,
	}
}

var TagsEnum_values = map[string]TagsFormat{
	TagsFormat_camelCase: TagsFormat_camelCase,
	TagsFormat_snakeCase: TagsFormat_snakeCase,
}

var TagsEnum_keys = map[TagsFormat]string{
	TagsFormat_camelCase: TagsFormat_camelCase,
	TagsFormat_snakeCase: TagsFormat_snakeCase,
}

func (e *TagsEnum) Set(value string) error {
	if val, ok := TagsEnum_values[strings.ToLower(value)]; ok {
		e.selected = val
		return nil
	}

	return fmt.Errorf("allowed values are %s", strings.Join(e.Enum, ", "))
}

func (e *TagsEnum) String() string {
	if val, ok := TagsEnum_keys[e.selected]; ok {
		return val
	}
	return ""
}

func main() {

	if err := NewGenGode().Run(os.Args); err != nil {
		log.Fatal(err)
	}

}

func NewGenGode() *cli.App {

	return &cli.App{
		Name:  "gen_code",
		Flags: joinFlags(baseFlags),
		Commands: []*cli.Command{
			structCMD,
		},
		Action: func(ctx *cli.Context) error {
			out, err := getOutPath(ctx)
			if err != nil {
				return err
			}
			package_name := os.Getenv("GOPACKAGE")

			fmt.Println("package:", package_name)
			fmt.Println("outpath:", out)
			return nil
		},
	}

}

var structCMD = &cli.Command{
	Name: "struct",
	Flags: joinFlags(
		baseFlags,
		structFlags,
	),
	Action: func(ctx *cli.Context) error {
		out, err := getOutPath(ctx)
		if err != nil {
			return err
		}

		structName := ctx.Args().First()

		fields := getFields(ctx)

		package_name := os.Getenv("GOPACKAGE")

		f := jen.NewFile(package_name)
		f.PackageComment("Code generated by generator, DO NOT EDIT.")

		if !ctx.Bool("no-struct") {
			f.Type().Id(structName).Struct(
				genStructFields(ctx, fields)...,
			).Line()
		}

		if ctx.Bool("getters") {
			for i := 0; i < len(fields); i += 2 {
				k, v := fields[i], fields[i+1]
				value := strcase.ToCamel(k)
				self := strings.ToLower(structName[:1])

				// TODO: currently doesn't handle non-pointer methods
				f.Func().Call(jen.Id(self).Id("*" + structName)).Id("Get" + value).Params().Id(v).Block(
					jen.Return().Id(self + "." + value),
				).Line()
			}
		}

		if ctx.Bool("setters") {
			for i := 0; i < len(fields); i += 2 {
				k, v := fields[i], fields[i+1]
				value := strcase.ToCamel(k)
				self := strings.ToLower(structName[:1])

				// TODO: currently doesn't handle non-pointer methods
				f.Func().Call(jen.Id(self).Id("*" + structName)).Id("Set" + value).Params(jen.Id("in").Id(v)).Block(
					jen.Id(self + "." + value).Op("=").Id("in"),
				).Line()
			}
		}

		if err := f.Render(out); err != nil {
			return err
		}
		return nil
	},
}

func getOutPath(ctx *cli.Context) (io.Writer, error) {
	var out = os.Stdout
	if s := ctx.Path("output"); s != "" {
		var err error
		out, err = os.Create(s)
		if err != nil {
			return nil, fmt.Errorf("get outpath: %w", err)
		}
	}
	return out, nil

}

func getFields(ctx *cli.Context) []string {
	out := []string{}
	kvs := strings.Split(ctx.String("fields"), ",")
	for _, kv := range kvs {
		split := strings.Split(kv, ":")
		if len(split) == 1 {
			out = append(out, split[0], "")
			continue
		}
		out = append(out, split[:2]...)
	}
	return out
}

func genStructFields(ctx *cli.Context, in []string) []jen.Code {
	out := []jen.Code{}
	for i := 0; i < len(in); i += 2 {
		k, v := in[i], in[i+1]

		code := jen.Id(strcase.ToCamel(k)).Id(v)

		if ctx.Bool("tags") {
			tf := ctx.String("tags-format")
			tag := strings.ToLower(k)
			tagName := strcase.ToLowerCamel(tag)
			if tf == TagsFormat_snakeCase {
				tagName = strcase.ToSnake(tag)
			}
			code = code.Tag(map[string]string{"json": tagName + ",omitempty", "yaml": tagName + ",omitempty"})
		}

		out = append(out, code)
	}
	return out
}
