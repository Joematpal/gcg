package main

import (
	"fmt"
	"go/types"
	"io"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/urfave/cli/v2"
	"golang.org/x/tools/go/packages"
)

func joinFlags(flagSet ...[]cli.Flag) []cli.Flag {
	out := []cli.Flag{}
	for _, flags := range flagSet {

		out = append(out, flags...)
	}
	return out
}

var baseFlags = []cli.Flag{
	&cli.PathFlag{
		Name:    "output",
		Usage:   "the destination where the end file needs to go",
		Aliases: []string{"o"},
	},
	&cli.StringFlag{
		EnvVars: []string{"GOPACKAGE"},
	},
}

var structFlags = []cli.Flag{
	&cli.StringFlag{
		Name:  "fields",
		Usage: "provide the fields with key:value comma seperated; make key snake_case to make it easier to handle capitals for acronyms",
	},
	&cli.BoolFlag{
		Name:    "tags",
		Aliases: []string{"t"},
		Usage:   "this will put the tags in either camel or snake case; default: camel",
	},
	&cli.GenericFlag{
		Name:    "tags-format",
		Aliases: []string{"tf"},
		Value:   NewTagsEnum(),
		Usage:   "this will put the tags in either camel or snake case; default: camel",
	},
	&cli.BoolFlag{
		Name:    "getters",
		Aliases: []string{"g"},
		Usage:   "",
	},
	&cli.BoolFlag{
		Name:    "no-struct",
		Aliases: []string{"ns"},
		Usage:   "allows you to print out the methods with the need for the struct",
	},
	&cli.BoolFlag{
		Name:    "setters",
		Aliases: []string{"s"},
		Usage:   "",
	},
}

type TagsFormat = string

const (
	TagsFormat_camelCase TagsFormat = "camel-case"
	TagsFormat_snakeCase TagsFormat = "snake-case"
)

type TagsEnum struct {
	Enum     []string
	Default  string
	selected string
}

func NewTagsEnum() *TagsEnum {
	return &TagsEnum{
		Enum: []string{
			TagsFormat_camelCase,
			TagsFormat_snakeCase,
		},
		Default: TagsFormat_camelCase,
	}
}

var TagsEnum_values = map[string]TagsFormat{
	TagsFormat_camelCase: TagsFormat_camelCase,
	TagsFormat_snakeCase: TagsFormat_snakeCase,
}

var TagsEnum_keys = map[TagsFormat]string{
	TagsFormat_camelCase: TagsFormat_camelCase,
	TagsFormat_snakeCase: TagsFormat_snakeCase,
}

func (e *TagsEnum) Set(value string) error {
	if val, ok := TagsEnum_values[strings.ToLower(value)]; ok {
		e.selected = val
		return nil
	}

	return fmt.Errorf("allowed values are %s", strings.Join(e.Enum, ", "))
}

func (e *TagsEnum) String() string {
	if val, ok := TagsEnum_keys[e.selected]; ok {
		return val
	}
	return ""
}

func main() {

	if err := NewGenGode().Run(os.Args); err != nil {
		fmt.Println("err", err)
		log.Fatal(err)
	}

}

func NewGenGode() *cli.App {

	return &cli.App{
		Name:  "gen_code",
		Flags: joinFlags(baseFlags),
		Commands: []*cli.Command{
			structCMD,
			grpcGwCMD,
			grpcConnectCMD,
		},
		Action: func(ctx *cli.Context) error {
			out, err := getOutPath(ctx)
			if err != nil {
				return err
			}
			package_name := os.Getenv("GOPACKAGE")

			fmt.Println("package:", package_name)
			fmt.Println("outpath:", out)
			return nil
		},
	}

}

var structCMD = &cli.Command{
	Name: "struct",
	Flags: joinFlags(
		baseFlags,
		structFlags,
	),
	Action: func(ctx *cli.Context) error {
		out, err := getOutPath(ctx)
		if err != nil {
			return err
		}

		structName := ctx.Args().First()

		fields := getFields(ctx)

		package_name := os.Getenv("GOPACKAGE")

		f := jen.NewFile(package_name)
		f.PackageComment("Code generated by generator, DO NOT EDIT.")

		if !ctx.Bool("no-struct") {
			f.Type().Id(structName).Struct(
				genStructFields(ctx, fields)...,
			).Line()
		}

		if ctx.Bool("getters") {
			for i := 0; i < len(fields); i += 2 {
				k, v := fields[i], fields[i+1]
				value := strcase.ToCamel(k)
				self := strings.ToLower(structName[:1])

				// TODO: currently doesn't handle non-pointer methods
				f.Func().Call(jen.Id(self).Id("*" + structName)).Id("Get" + value).Params().Id(v).Block(
					jen.Return().Id(self + "." + value),
				).Line()
			}
		}

		if ctx.Bool("setters") {
			for i := 0; i < len(fields); i += 2 {
				k, v := fields[i], fields[i+1]
				value := strcase.ToCamel(k)
				self := strings.ToLower(structName[:1])

				// TODO: currently doesn't handle non-pointer methods
				f.Func().Call(jen.Id(self).Id("*" + structName)).Id("Set" + value).Params(jen.Id("in").Id(v)).Block(
					jen.Id(self + "." + value).Op("=").Id("in"),
				).Line()
			}
		}

		if err := f.Render(out); err != nil {
			return err
		}
		return nil
	},
}

func getOutPath(ctx *cli.Context) (io.Writer, error) {
	var out = os.Stdout
	if s := ctx.Path("output"); s != "" {
		var err error
		out, err = os.Create(s)
		if err != nil {
			return nil, fmt.Errorf("get outpath: %w", err)
		}
	}
	return out, nil

}

func getFields(ctx *cli.Context) []string {
	out := []string{}
	kvs := strings.Split(ctx.String("fields"), ",")
	for _, kv := range kvs {
		split := strings.Split(kv, ":")
		if len(split) == 1 {
			out = append(out, split[0], "")
			continue
		}
		out = append(out, split[:2]...)
	}
	return out
}

func genStructFields(ctx *cli.Context, in []string) []jen.Code {
	out := []jen.Code{}
	for i := 0; i < len(in); i += 2 {
		k, v := in[i], in[i+1]

		code := jen.Id(strcase.ToCamel(k)).Id(v)

		if ctx.Bool("tags") {
			tf := ctx.String("tags-format")
			tag := strings.ToLower(k)
			tagName := strcase.ToLowerCamel(tag)
			if tf == TagsFormat_snakeCase {
				tagName = strcase.ToSnake(tag)
			}
			code = code.Tag(map[string]string{"json": tagName + ",omitempty", "yaml": tagName + ",omitempty"})
		}

		out = append(out, code)
	}
	return out
}

var grpcGwCMD = &cli.Command{
	Name: "grpc-gateway",
	Action: func(ctx *cli.Context) error {
		out, err := getOutPath(ctx)
		if err != nil {
			return err
		}
		structName := ctx.Args().First()
		_ = structName
		package_name := os.Getenv("GOPACKAGE")

		f := jen.NewFile(package_name)
		f.PackageComment("Code generated by generator, DO NOT EDIT.")

		// Load Package...
		if err := f.Render(out); err != nil {
			return err
		}

		return nil
	},
}
var grpcConnectCMD = &cli.Command{
	Name: "grpc-connect",
	Flags: []cli.Flag{
		&cli.StringFlag{
			Name: "grpc-gateway-implementation",
		},
		&cli.PathFlag{
			Name:    "output",
			Usage:   "the destination where the end file needs to go",
			Aliases: []string{"o"},
		},
		// &cli.StringFlag{
		// 	Name: "",
		// },
	},
	Action: func(ctx *cli.Context) error {
		out, err := getOutPath(ctx)
		if err != nil {
			return err
		}

		// structName := ctx.Args().First()
		// currentFile := os.Getenv("GOFILE")

		// wd, err := os.Getwd()
		// if err != nil {
		// 	return err
		// }

		package_name := os.Getenv("GOPACKAGE")

		f := jen.NewFile(package_name)
		f.PackageComment("Code generated by generator, DO NOT EDIT.")

		// goPath := os.Getenv("GOPATH")

		fp := "/home/joseph/go/src/github.com/digital-dream-labs/sai-subscriptions/internal/subscriptions/subscriptions.go"
		// fp := filepath.Join(wd, currentFile)
		fmt.Println("fp:", fp)
		pkgs, err := loadPackage(fp)
		if err != nil {
			return err
		}

		fmt.Println("pkgs.Name", pkgs.Name)

		fmt.Printf("pkgs: %#v\n", pkgs)
		structName := "Subscriptions"
		fmt.Println("struct to look up", structName)
		// fmt.Printf("types: %#v\n", pkgs.Types)
		scope := pkgs.Types.Scope()
		// fmt.Printf("scope: %#v\n", scope)
		obj := scope.Lookup(structName)
		fmt.Println("obj", obj == nil)
		// 4. We check if it is a declared type
		if _, ok := obj.(*types.TypeName); !ok {
			return fmt.Errorf("%v is not a named type", obj)
		}
		// 5. We expect the underlying type to be a struct
		structType, ok := obj.Type().Underlying().(*types.Struct)
		if !ok {
			return fmt.Errorf("type %v is not a struct", obj)
		}
		// 6. Now we can iterate through fields and access tags
		for i := 0; i < structType.NumFields(); i++ {
			field := structType.Field(i)
			tagValue := structType.Tag(i)
			fmt.Println(field.Name(), tagValue, field.Type())
		}
		// Load Package...
		if err := f.Render(out); err != nil {
			return err
		}
		return nil
	},
}

func loadPackage(path string) (*packages.Package, error) {
	// cfg := &packages.Config{Mode: packages.NeedFiles | packages.NeedSyntax | packages.NeedTypesInfo}
	cfg := &packages.Config{Mode: packages.NeedTypes}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		return nil, fmt.Errorf("load: %v", err)
	}

	// if packages.PrintErrors(pkgs) > 0 {
	// 	return nil, err
	// }
	fmt.Println("len of pkgs", len(pkgs))

	return pkgs[0], nil
}

func splitSourceType(sourceType string) (string, string, error) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		return "", "", fmt.Errorf(`expected qualified type as "pkg/path.MyType"`)
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName, nil
}
